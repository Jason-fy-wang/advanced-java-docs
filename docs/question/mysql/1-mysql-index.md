---
tags:
  - mysql
  - interview
---


# mysql的面试问题

## 1. 索引优化
1) 选择合适的索引列
	* 优先给高基数(distinct 值多), 查询频繁的列建立索引
	* 避免给更新很频繁且基数低的列(如 性别字段)建立索引, 否则维护成本太高
2) 覆盖索引(covering index)
    * SELECT 的所有字段都包含在索引中, 则只读索引树, 避免回表, 性能高
3) 符合索引最左前缀原则
    * 如果 INDEX(a,b,c), 则对a,  (a,,b),  (a,b,c), 的查询可走索引, 对 (b,c) 或 (c) 则无法使用该索引
4) 面泛索引失效的写法
     * NOT  函数  ,隐式类型转换,  前缀模糊查询(LIKE '%xxx') 等都会导致全表扫描
5) 分区白哦与分库分表
     * 针对大数据量, 科按某字段分区(Partition)  或 分库分表,  减少单表数据量和索引树高度
6) 索引合并与多列查询
    * MySQL 会对多个单列索引做 Index Merge, 但往往不如一个覆盖所有查询条件的符合索引高效




## 2.索引失效
一下会导致WHERE 条件无法走索引:
* 对索引列做函数 或 表达式
```SQL
WHERE Date（create_time)  = '2025-06-19';
```
* 前缀通配符 LIKE
```SQL
WHERE name like '%zhang%';
```
* 隐式类型转换
```SQL
where id = '123'; -- convert to int 
```
* OR 连用 且 每个分支无法各自用上索引
```SQL
where a=1 or b=2; --若只有a,b的单列索引, MySQL 可能不做 Index Merge
```
* NOT / <> / IS NULL 
```SQL
where a <> 5;
where a is null;
```


## 3. 底层存储b-树 b+树

| 特性      | B-Tree            | B+Tree                       |
| ------- | ----------------- | ---------------------------- |
| 结构      | 所有节点(叶子和非叶子)都存有数据 | 只有叶子节点存有数据, 非叶子节点仅存建索引       |
| 叶子链表    | 无                 | 叶子节点通过双向链表相连接, 范围查询非常高效      |
| 非叶子节点大小 | 存数据导致节点"胖", 高度略低  | 非叶子节点更小, 可存更多索引项, 树更瘦, 高度更低  |
| IO 磁盘访问 | 随机查询会多次随机访问磁盘     | 一次查到叶子后, 可以顺序遍历链表, 大幅减少随机I/O |
|         |                   |                              |



## 4. mysql 主从集群同步延迟如何解决
1. 网络优化
	* 确保主从网络延迟低, 带宽足够, 可部署在同一机房或使用专线
2. 硬件升级
    * 从库磁盘IO, CPU ,内存都要足够, 否则SQL 线程拉取数据后执行满导致堆积
3. 复制线程调整
     * 并行复制
     * salve_parallel_workers 参数, 开启多worker 并行执行不同库或同库不同事务
4. 读写分离与架构设计
     *  把只读查询都引导到从库, 减轻从库CPU/IO 压力
     * 对热点写入场景, 可考虑分库分表或使用中间件(proxy)
5. SQL优化
     * 减少大事务. 大事务拆小, 避免binlog 巨量写入, 从而让从库拉取, 执行慢
     * 避免长查询: 慢查询优化后, 减少slave SQL 线程执行时间
6. 监控与报警
     * 监控 Seconds_Behind_Master, 及时发现延迟过高问题并定位原因


## 5. redolog undolog  binlog 的作用与区别
| 日志       | 作用                                         | 存放位置        | 读写顺序             |
| -------- | ------------------------------------------ | ----------- | ---------------- |
| Redo Log | 崩溃恢复:  记录事务对InnoDB数据页的物理修改, 用于宕机后重新做未刷盘的修改 | 磁盘文 件 (预分配) | 写 -> 刷盘          |
| Undo Log | 事务回滚: 保存旧版本镜像, 用于事务回滚或MVCC 多版本并发控制         | 数据文件        | 写 -> 无需刷盘 (延后刷盘) |
| BinLog   | 只从复制& 增量备份:  以事件或行形式记录所有事务提交操作, 供从库重放及物理备份 | 存于 磁盘       | 写 ->  刷盘         |


## 6. redolog 和 binlog 除了作用不同, 在文件格式上有什么不同?

| 特性   | RedoLog                                 | BinLog                                  |
| ---- | --------------------------------------- | --------------------------------------- |
| 存储格式 | 固定大小的循环文件(Log File+Log Buffer)          | 按时间滚动的多个文件（.000001, .000002)            |
| 记录粒度 | 页(page)级别的物理写入, 记录对页的二进制修改(物理日志)        | 语句或行事件驱动的逻辑日志(逻辑或行级别日志)                 |
| 可读性  | 二进制流, 不可直接解析, 只能靠InnoDB 恢复模块            | 文本或半文本,(Row 模式为二进制事件), 可用mysqlbinlog 查看 |
| 覆盖方式 | 循环写: 文件用满后从头覆盖最旧日志, 依赖checkPoint 保留必要日志 | 顺序追加, 不会覆盖旧文件, 人工策略清理或expire_logs_days  |
| 依赖关系 | 仅对InnoDB 自身, MySQL 不直接读取redo log        | 整个server 级别, 复制与备份必须读取binlog            |



