---
tags:
---
## 1. hashmap为什么默认初始化是16 (偶数)个？
HashMap底层数组长度为2的幂， 是为了让计算下表的求模运算更高效:
```shell
index = (n-1) & hash
```
* 当n是2 的幂时， &(n-1) 等价于 hash%n.  但是底层只是做了位运算， 比取模快的多。
* 如果通过参数指定了长度, 内部会把5 向上取整 到最近2的幂.  

## 2. hashMap为什么节点多了，就转换红黑树
* 默认情况下, 当Hash 碰撞冲突会在同一个桶里用链表串起来.
* 链表最坏查找时间O(n), 当某个桶里积累了很多节点时, 频繁的 get/put 效率急剧下降
* JDK8 引入红黑树, 当单个桶链表长度超过 TREEIFY_THRESHOLD=8时, 会把此链条转换为红黑树, get/put/remove 能降低到 O(logn).
* 只有当整个 table的容量达到 MIN_TREEIFY_CAPACITY=64时, 才会 "树化", 即使链长>8.  此是避免在小表上过早 "树化".
```java
static final int TREEIFY_THRESHOLD = 8;  
static final int UNTREEIFY_THRESHOLD = 6;
static final int MIN_TREEIFY_CAPACITY = 64;
```


## 3. hashMap红黑树转换回来为正常结构时，为什么阈值为6
* 反树化 `UNTREEIFY_THRESHOLD = 6`设置为6, 是为了增加一点缓冲,  避免链长在 7, 8 来回波动就不同的树化, 反树化.
* 当某个桶里树节点跌到 <=6时, JDK 会把红黑树拆回链表,  以保持结构简单, 节省节点指针开销.





