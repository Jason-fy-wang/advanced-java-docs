[TOC]

# 时间和空间复杂度的计算

算法指用来操作数据，解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在消耗的资源和时间却有很大的区别。

那么如何衡量不同算法之间的优劣呢？

主要还时从算法所占用的时间和空间两个维度去考量。

* 时间维度：是指执行当前算法所消耗的时间，我们通常用时间复杂度来描述
* 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用空间复杂度来描述

## 时间复杂度

想计算一个算法的时间复杂度，很多人想到的是把这个算法运行一遍，那么它所消耗的时间就自然而然知道了。这种方法当然可以，不过有很多弊端。

这种方法非常容易受运行环境的影响，在性能高的机器上跑出来的结果与在性能低的机器上结果相差很大。而且对测试的使用的数据规模也有很大关系。再者，在写算法的时候，还没有方法完成的去运行呢。

因此，另一种通用的方法就出来了：【大O符号表示法】，即T(n) = O(f(n))

来看一个栗子：

```java
for(int i=1; i<=n;i++){
    j = i;
    j++;
}
```

通过大O表示法，这段代码的时间复杂度为：O(n)，为什么呢？

在大O符号表示法中，时间复杂度公式是：T(n) = O(f(n))，其中f(n)表示每行代码执行次数之和，而O表示正比例关系，这个公式的全称是：**算法的渐进时间复杂度。**

继续看上面例子：假设每行代码的执行时间都是一样的，我们用1颗粒时间来表示，那么这个例子的第一行耗时是1个颗粒时间，第二行耗时n个颗粒时间，第三行也是n个颗粒时间，那么总时间就是1+n+n颗粒时间，即（1+2n）个颗粒时间，即T(n) = (1+2n)*颗粒时间，从这个结果看，这个算法的耗时是随着n的变化而变化，因此可以简化的将这个算法的时间复杂度表示为 T(n)=O(n)。

为什么可以这么去简化呢？因为大O符号表示法并不是用来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。

所以上面的例子中，如果n无限大，T(n)=time(1+2n)中的常量1就没有意义了，倍数2也意义不大。因此直接简化为T(n)=O(n)就可以了。

常见的时间复杂度量级有：

* 常数阶O(1)
* 对数阶O(logN)
* 线性阶O(n)
* 线性对数阶O(nlogN)
* 平方阶O(n^2)
* 立方阶O(n^3)
* K次方阶O(n^k)
* 指数阶O(2^n)

从上到下依次的时间复杂度越来越大，执行的效率越来越低。

### 1. 常数阶O(1)

无论代码执行了多少行,只要是没有循环等复杂结构,那这个代码的时间复杂度就都是O(1)

```java
int i =1;
int j = 2;
i++;
j++;
int m = i+j;
```



### 2.对数阶O(logN)

```java
for(int i=1; i<=n;i++){
    j=i;
    j++;
}
```

这段代码，for循环里面的代码会执行n遍，因此耗时的时间是随着n的变化而变化的，因此这类代码可以用O(n)来表示它的时间复杂度。

### 3.线性阶O(n)

```java
int i = 1;
while(i < n){
    i = i*2;
}
```

这段代码可以看到，每次都将i乘以2，乘完之后，i距离n也就越来越近了。我们试着求解一下，假设循环x次之后，i就大于2了，此时循环退出，也就是说2的x次方等于n，那么x=log(2)N--(以2为底的N的对数)。

也就是说当循环log(2)N次后，这个代码流结束了。因此这个代码的时间复杂度为O(logN).

### 4.线性对数阶O(nlogN)

线性对数阶O(nlogN)其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是n*O(logN)，也就是O(nlogN)

```java
for (int i=1;i<=n;i++){
    int m=1;
    while(m < n){
        m = m*2;
    }
}
```



### 5.平方阶O(n^2)

平方阶O(n^2)也比较容易理解，如果把O(n)的代码再嵌套循环一遍,它的时间复杂度就是O(n^2).

```java
for (int i=1;i<n;i++){
    for (int j=1;j<n;j++){
        sum = i+j;
    }
}
```

```java
for (int i=1;i<m;i++){
    for (int j=1;j<n;j++){
        sum = i+j;
    }
}
/**
此例子的时间复杂度就是O(m*n)
*/
```



### 6.立方阶O(n^3)

平方阶O(n^3)也比较容易理解，如果把O(n^2)的代码再嵌套循环一遍,它的时间复杂度就是O(n^3).

```java
for(int k=1;k<n;k++){
    for (int i=1;i<n;i++){
        for (int j=1;j<n;j++){
            sum = i+j;
        }
    }
}
```



### 7.K次方阶O(n^k)



### 8.指数阶O(2^n)



### 9.logn

二分查找法:

```java
//二分查找 Java 实现
public static int binarySearch(Integer[] srcArray, int des) {
    int low = 0;
    int high = srcArray.length - 1;

    while ((low <= high) && (low <= srcArray.length - 1)
            && (high <= srcArray.length - 1)) {
        int middle = (high + low) >> 1;
        if (des == srcArray[middle]) {
            return middle;
        } else if (des < srcArray[middle]) {
            high = middle - 1;
        } else {
            low = middle + 1;
        }
    }
    return -1;
}
```

二分查找法的时间复杂度: 每次查找的大小分别为: n，n/2，n/4，n/2^k，即当n/2^k此查找时，找到值，那么公式为: n/2^k = 1，那么k=log(2)n，即以2为底的n的对数，所以时间复杂度为O(logn)





## 空间复杂度

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映出的是一个趋势，我们用S(n)来定义。

空间复杂度比较常用的:O(1)，O(n)，O(n^2)

### 1.空间复杂度O(1)

```java
int i=1;
int j=2;
i++;
j++;
int m=i+j;
```

算法执行所需要的的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量。代码中的i，j，m所分配的空间都不随着处理数据量变化，因此它的空间复杂度为S(n) = O(1).



### 2.空间复杂度O(n)

```java
int[] m = new int[n];
for (int i=1; i<=n; i++){
    j = i;
    j++;
}
```

第一行new出一个数组来，这个数据占用大小为n，后面的代码，虽然有循环，但没有再分配新的空间，因此此段代码的空间复杂度为 S(n) = O(n);

























































