# CMS收集器介绍

CMS是JVM设计的一款优秀的老年代垃圾收集器，也可以称作Mostly-Concurrent收集器。低延迟是它的优势，采用的是标记-清除算法，也会有stop-the-world机制出现。

## 执行的过程

CMS的执行阶段一种有四部分：

1. 初始标记阶段(Initial-mark)-(stop the world)
2. 并发标记阶段(Concurrent-Marking)
3. 再次标记阶段(Remark)(stop-the-world)
4. 并发清除阶段(Concurrent-Sweep)

CMS收集的回收周期以一个称为初始标记阶段开始。下面介绍一下各个阶段的作用：

* 初始标记阶段

在初始标记阶段，程序中所有的工作线程都会因为stop-the-world机制而出现短暂的暂停，这个阶段的主要任务就是标记内存中那些集合所连接的目标对象是否可达，一旦标记完成之后就会恢复之前被暂停的所有应用线程。此阶段是单线程。

* 并发标记阶段

初始标记结束后，将进入并发标记阶段，这个阶段的主要任务就是将之前不可达的对象标记为垃圾对象。在CMS最终执行内存回收之前，尽管看上去这些垃圾对象都已经被成功标记，但是由于在并发标记阶段，程序的工作线程和垃圾收集线程同时运行或者交叉运行，因此在并发标记阶段将无法有效确保之前被标记为垃圾的无用对象的引用遭到修改。

* 再次标记阶段

为了解决上面的问题，CMS会进入到再次标记阶段，这样一来，程序会因为stop-the-world 机制而再次出现短暂的暂停，以确保这些垃圾对象都能够被成功且正确的标记。

* 并发清除

经过上面三个阶段后，CMS最终将会进入到并发清除阶段执行内存回收，释放掉无用对象所占用的内存空间。

图片示例：

![](../image/CMS.png)

## 副作用

### 1. 仍然会有暂停

尽管CMS采用的是并行回收，但是在其初始化标记和再次标记这两个阶段中仍然需要执行stop-the-world机制暂停程序中的工作线程，不过暂停时间并不会太长。可以说明CMS只是尽可能降低暂停时间，做不到完全不需要stop-the-world。

### 2. 内存碎片

CMS采用的是标记-清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免的产生内存碎片。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞技术，只能够选择空闲列表执行内存分配。

**指针碰撞：** 在连续剩余空间分配内存。用一个指针指向内存已用区和空闲区的分界点，需要分配新的内存的时候，只需要将指针指向空闲区移动相应的距离就可以。

简单来说，JVM会负责维护一个列表，其中所记录的内容就是当前内存空间中可用内存块的坐标，当执行内存分配时，会从列表中定位到一个与新对象所需内存大小一致的连续内存块用于存储生成的对象实例。

CMS提供选项 -XX:+UseCMSCompactAtFullCollection，用于指定在执行完Full GC后是否对内存空间进行压缩整理，一次避免内存碎片的产生。不过内存压缩整理不能执行，所带来的问题就是停顿时间更长。CMS提供了另外一个选项: -XX:CMSFullGCsBeforeCompact ，用于设置在执行了多少次Full GC后对内存空间进行压缩整理。

### 3. 垃圾清除不完全

CMS另一个问题就是在并发标记阶段由于程序的工作线程和垃圾收集线程时同时运行或交叉运行，最终会导致这些新产生的垃圾对象没有被及时的标记，从而只能在下一次执行GC时回收。

