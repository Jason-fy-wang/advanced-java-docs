# 选举实现

本篇来分析一下zk的选举机制实现，其中跟选举有很大关系的一个类主要是：QuorumPeer，FastLeaderElection，QuorumCnxManager。

其中简单理解`QuorumPeer`表示当前zk实例的一个具体类，`FastLeaderElection`表示选举算法，`QuorumCnxManager`用于管理和其他zk实例的通信，下面就来看一下具体的选举流程。

## 1. QuorumPeer 实例启动

从zk的启动类来开始分析：

> org.apache.zookeeper.server.quorum.QuorumPeerMain#main

```java
    public static void main(String[] args) {
        // 创建一个 QuorumPeerMain
        QuorumPeerMain main = new QuorumPeerMain();
        try {
            // 根据传递进来的参数 进行初始化
            main.initializeAndRun(args);
        }
        ......
        System.exit(0);
    }
```

> org.apache.zookeeper.server.quorum.QuorumPeerMain#initializeAndRun

```java
protected void initializeAndRun(String[] args)
    throws ConfigException, IOException, AdminServerException
    {
        // 创建一个配置类,主要用来保存配置文件中的配置
        QuorumPeerConfig config = new QuorumPeerConfig();
        if (args.length == 1) {
            // 配置文件解析
            // 创建server机器信息
            config.parse(args[0]);
        }

        // Start and schedule the the purge task
        // 数据清理线程  snap 快照清理
        DatadirCleanupManager purgeMgr = new DatadirCleanupManager(config
                .getDataDir(), config.getDataLogDir(), config
                .getSnapRetainCount(), config.getPurgeInterval());
        purgeMgr.start();
        // 集群模式
        .....
        runFromConfig(config);
    }
```

> 

```java
 // 即从配置开始运行
    // 即把读取到的配置 设置到 QuorumPeer中,并开始了真正的运行
    public void runFromConfig(QuorumPeerConfig config)
            throws IOException, AdminServerException
    {
      LOG.info("Starting quorum peer");
      try {
          ServerCnxnFactory cnxnFactory = null;
          ServerCnxnFactory secureCnxnFactory = null;
            // getClientPortAddress 获取客户端登录时的地址
          if (config.getClientPortAddress() != null) {
              // 通过反射创建NIOServerCnxnFactory, NIO 通信
              // ***************************************************
              cnxnFactory = ServerCnxnFactory.createFactory();
              // 创建 NioServerSocket 以及 worker处理IO的线程
              // 对NioServer进行一些配置
              cnxnFactory.configure(config.getClientPortAddress(),
                      config.getMaxClientCnxns(),
                      false);
          }
            // 创建 quorumPeer
          quorumPeer = getQuorumPeer();
         // 下面就是把从配置文件中读取的内容配置到 quorumPeer中
         // quorumPeer其实就是当前zk实例的一个抽象
          // 选举算法
          // ElectionType 记录了具体的选举方式,也就是指定了选举算法
          quorumPeer.setElectionType(config.getElectionAlg());
          quorumPeer.setConfigFileName(config.getConfigFilename());
          // 数据树 除了在磁盘有一份保存外,还有一份在 内存中有一个信息树
          // 此处就是创建 内存中的数据树
          // *************************************
          quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));
          // getQuorumVerifier此属性很重要,记录了集群中的其他节点的信息,以及各个节点的角色
          // 使用AddressTuple 记录地址
          quorumPeer.setQuorumVerifier(config.getQuorumVerifier(), false);
          if (config.getLastSeenQuorumVerifier()!=null) {
              quorumPeer.setLastSeenQuorumVerifier(config.getLastSeenQuorumVerifier(), false);
          }
          quorumPeer.initConfigInZKDatabase();
		...... // 省略非关键代码 
          // auth相关的配置
          quorumPeer.initialize();
          // 启动
          quorumPeer.start();
          // 等待线程结束
          quorumPeer.join();
      }
    }
```

> org.apache.zookeeper.server.quorum.QuorumPeer#start

```java
 @Override
    public synchronized void start() {
        if (!getView().containsKey(myid)) {
            throw new RuntimeException("My id " + myid + " not in the peer list");
         }
        // 加载磁盘数据
        loadDataBase();
        // selector 接收客户端请求 并进行处理
        // 一个selector 多个worker 和 netty 很像
        // ************************************服务端请求接收****************
        startServerCnxnFactory();
        try {
            adminServer.start();
        } catch (AdminServerException e) {
            LOG.warn("Problem starting AdminServer", e);
            System.out.println(e);
        }
        // 开始leader选举前的准备
        startLeaderElection();
        // 开始选举
        // 注意 QuorumPeer 也就是本class 也是一个线程
        // 也就是说,此处的start会运行本类的run方法
        super.start();
    }
```

> org.apache.zookeeper.server.quorum.QuorumPeer#start

```java
// zk实例的启动
@Override
public synchronized void start() {
    // 加载 内存数据库
    loadDataBase();
    // 对外服务端口 开始监听
    cnxnFactory.start();
    // 开始选举
    // 此会创建对其他实例的scoket连接, 以及运行相关的数据 收发线程,为leader竞争做准备
    startLeaderElection();
    // 当前 线程开始运行,当前线程 可以抽象的认为 代表当前的zk实例,会进行投票
    // 开始进行leader的竞争
    super.start();
}
```

在这里呢，四个函数，做了非常重要的四种工作：

1. loadDataBase  内存数据库的创建
2. cnxnFactory.start() 对外服务接口，即常见的2181的服务的创建
3. startLeaderElection() 准备好了选举操作
4. super.start()  开启当前线程，主要是做了(1) leader选举，(2) 如果是leader则创建了和follower的数据沟通server；如果是follower则尝试跟leader进行同步

本篇主要讲解leader选举，故从后面2个函数调用入手。

## 2. startLeaderElection

> org.apache.zookeeper.server.quorum.QuorumPeer#startLeaderElection

```java
// 开始leader的选举
synchronized public void startLeaderElection() {
    try {
        // 创建当前初始的选票
        // 即第一次选票是投票给自己
        currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());
    }
    // view其实就是 集群中的server信息(有参与权),从配置文件中解析的
    // 这里主要是获取自己的 地址
    for (QuorumServer p : getView().values()) {
        if (p.id == myid) {
            // 获取当前节点对应的通信地址
            myQuorumAddr = p.addr;
            break;
        }
    }
    // 根据指定的选举类型
    // 创建选举算法
    this.electionAlg = createElectionAlgorithm(electionType);
}
```

这里主要是:

1. 设置当前的选票为自己
2. 获取当前zk实例的地址
3. 创建选举算法

> org.apache.zookeeper.server.quorum.QuorumPeer#createElectionAlgorithm

```java
protected Election createElectionAlgorithm(int electionAlgorithm){
    Election le=null;
    // 其三种的选举算法  其实已经过期
    switch (electionAlgorithm) {
        case 0:
            le = new LeaderElection(this);
            break;
        case 1:
            le = new AuthFastLeaderElection(this);
            break;
        case 2:
            le = new AuthFastLeaderElection(this, true);
            break;
        case 3:
            // 此manager用于管理和其他zk的通信
            qcm = createCnxnManager();
            // 获取对应的接收 或 创建到其他zk实例连接的listener
            // 此listener会使用接收的socket创建到其他zk实例的 消息发送线程sendworker  消息接收线程recvWorker,并启动
            QuorumCnxManager.Listener listener = qcm.listener;
            if(listener != null){
                // 开始监听其他zk实例到当前实例监听地址的socket连接
                listener.start();
                // 选举的算法
                le = new FastLeaderElection(this, qcm);
            } else {
                LOG.error("Null listener when initializing cnx manager");
            }
            break;
        default:
            assert false;
    }
    return le;
}
```

这里最终使用的选举算法其实是FastLeaderElection，从代码中看前面三个算法其实已经不推荐使用了。

这里呢创建了几个对象，其实都是比较重量级的，大概说一下每个类的作用:

1. createCnxnManager  创建 CnxnManager 其主要功能就是管理和其他zk实例的socket连接，以及对应的选票数据发送的sendWork和选票的接收的 recvWorker
2. QuorumCnxManager.Listener  其实是一个ServerSocket，主要用于接收其他zk实例的socket连接；QuorumCnxManager.Listener其监听的端口其实是leader的选举端口
3. FastLeaderElection  这是实现leader选举的算法

下面去解析一下前两个类的功能。

### 2.1 CnxnManager 

> org.apache.zookeeper.server.quorum.QuorumPeer#createCnxnManager

```java
public QuorumCnxManager createCnxnManager() {
    // 创建QuorumCnxManager
    return new QuorumCnxManager(this.getId(),
                                this.getView(),
                                this.authServer,
                                this.authLearner,
                                this.tickTime * this.syncLimit,
                                this.getQuorumListenOnAllIPs(),
                                this.quorumCnxnThreadsSize,
                                this.isQuorumSaslAuthEnabled());
}
```

> org.apache.zookeeper.server.quorum.QuorumCnxManager#QuorumCnxManager

```java
public QuorumCnxManager(final long mySid,
                        Map<Long,QuorumPeer.QuorumServer> view,
                        QuorumAuthServer authServer,
                        QuorumAuthLearner authLearner,
                        int socketTimeout,
                        boolean listenOnAllIPs,
                        int quorumCnxnThreadsSize,
                        boolean quorumSaslAuthEnabled) {
    this(mySid, view, authServer, authLearner, socketTimeout, listenOnAllIPs,
         quorumCnxnThreadsSize, quorumSaslAuthEnabled, new ConcurrentHashMap<Long, SendWorker>());
}




public QuorumCnxManager(final long mySid,
                        Map<Long,QuorumPeer.QuorumServer> view,
                        QuorumAuthServer authServer,
                        QuorumAuthLearner authLearner,
                        int socketTimeout,
                        boolean listenOnAllIPs,
                        int quorumCnxnThreadsSize,
                        boolean quorumSaslAuthEnabled,
                        ConcurrentHashMap<Long, SendWorker> senderWorkerMap) {
    // 记录发送消息worker的容器
    this.senderWorkerMap = senderWorkerMap;
    // 接收队列
    this.recvQueue = new ArrayBlockingQueue<Message>(RECV_CAPACITY);
    // 每个server实例对应一个待发送的 队列,存储其中要发送的数据
    this.queueSendMap = new ConcurrentHashMap<Long, ArrayBlockingQueue<ByteBuffer>>();
    // 每个server上次发送的信息
    this.lastMessageSent = new ConcurrentHashMap<Long, ByteBuffer>();
    String cnxToValue = System.getProperty("zookeeper.cnxTimeout");
    if(cnxToValue != null){
        this.cnxTO = Integer.parseInt(cnxToValue);
    }

    this.mySid = mySid;
    this.socketTimeout = socketTimeout;
    // 集群中的server信息
    this.view = view;
    this.listenOnAllIPs = listenOnAllIPs;
    // 认证相关
    initializeAuth(mySid, authServer, authLearner, quorumCnxnThreadsSize,
                   quorumSaslAuthEnabled);

    // Starts listener thread that waits for connection requests
    // 此listener 会接收 或者 创建到其他zk实例的连接
    // 并利用创建的socket连接,创建具体的消息发送者 sendWorker  消息接收recvWorker 线程
    // 并启动对应的接收和发送线程
    // 这里创建好之后,就会leader选举 做好了准备(发送选票等信息)
    listener = new Listener();
}
```



### 2.2  QuorumCnxManager.Listener

Listener  其实就是一个线程并监听对应的







## 3. QuorumPeer  run















































